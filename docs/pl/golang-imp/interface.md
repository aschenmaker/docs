# Interface{}的底层实现

!!! note "Interface 接口"
		在计算机科学中，接口是一个 **共享边界** ，计算机系统的独立组件之间，可以通过该共享边界来进行数据交换。这种信息交换可以在软件、硬件、外围设备、甚至与人之间进行。接口的存在无疑是带来好处的：
		
		1. **隐藏细节** ： 接口对对象进行了必要的抽象。只要满足接口，那么就可以进行对接，不必关注如何实现了接口。
		2. **控制系统复杂性** ：通过接口我们可以通过`模块化`构建负责而庞大的系统。将系统拆分成模块。
		3. **权限控制** ： 接口是系统与外界交流的唯一途径，通过对接口接入方式和接入行为的控制，保证安全。



由于本文主要介绍的是接口的实现，在对于接口的介绍上会相对的简练。在此之前你需要学会如何使用接口。

## 1 go 语言中的接口

Go语言中的接口是一种特殊的类型。由于Go语言中不存在继承，接口的存在帮助我们实现扁平化、面向组和的设计模式。

有两种形式的接口，他们的底层实现并不一样。

### 1.1 带有方法签名的接口

带有方法签名的接口内部包含其他类型可以实现的方法签名的集合。接口的实现是隐式的，只要实现了接口中全部的方法签名，那么就实现了接口。

```go
type InterfaceWithFunc interface{
  funcA()
  funcB(a int, b int) int
}
```



### 1.2 空接口

空接口是不包含签名的接口，

```go
type InterfaceN interface {}
```

空接口提供了强大的抽象能力，比如我们使用的输入输出函数`fmt.Println(a ...interface{})`，空接口的存在是的我们不用对每一种类型提供一个Println函数。

> 当然这个在go正式引入范型之后，我们也可以通过范型来实现。Interface的类型断言，位于runtime下，而如果使用了范型则通过编译器对多种类型进行编译。

进行类型断言的语法`i.(type)`，使用switch函数来对断言类型进行判断：

```go
switch f := arg.(type) {
case bool :
  p.fmtBool(f, verb)
...
case int64 :
  p.fmtInt:
...
}
```

