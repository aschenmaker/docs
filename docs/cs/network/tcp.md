# 从TCP说起

!!! note "TCP"
		TCP作为可靠性协议，它是如何保持传输的可靠性呢？
      1. 首先可靠必须对各种状态进行记录，如何确立状态的
      2. 建立了什么样的数据结构，来保证了TCP的特性
      3. 如何保证TCP面对黑盒的底层网络，如何来感知网络情况。激进的抢占，还是保守的退缩？



## TCP的包头格式

32bit宽度。

![tcp头](https://dist.lyneee.com/blog/2021-09-08-tcp-head.gif)

- 源端口号 目标端口号 
  - 确定了将数据传送给哪一个监听的应用
- 序号
  - 解决的乱序的问题
- 确认序号
  - 发出去的包就会有确认，来保证已经收到
- 状态位置 - 通过此来维护连接状态
  - syn发起一个连接
  - ack收到回复
  - rst重新连接
  - fin结束连接状态
  - ……
- 窗口大小
  - 通过此坐流量控制

总结起来有这些关键词：

- 顺序
- 丢包
- 连接维护
- 流量控制
- 拥塞控制

## TCP的三次握手

![三次握手](https://dist.lyneee.com/blog/2021-09-08-3hands.png)

一开始服务端和客户端都处于关闭状态。现实服务端对某一个端口进行了监听，处于Listen状态。然后客户端发起SYN监理连接，处于SYN_SENT状态。服务端收到了发起的连接请求后，会返回SYN，ack客户端的syn+1，处于SYN_RCVD状态。客户端在收到后，回复ACK，同时ack服务端的SYN，处于建立连接的状态。服务端收到了客户端的ACK后则进入ESTABLESHED转台。握手完毕。双方都处于一次发送一次接受。连接建立。

## TCP的四次挥手

![四次挥手](https://dist.lyneee.com/blog/2021-09-08-4.png)

断开的时候，断开链接的一方A发送FIN，进入FIN_WAIT_1的阶段，当被断开链接的一方B收到后，回复一个已收到ACK，进入到CLOSE_WAIT状态，这时候，B会将没有处理完的状态信息等进行处理。A收到请求后进入到FIN_WAIT_2的状态。B处理完成后，会发送FIN给A，A收到后回进入到TIME_WAIT的状态，返回给ACK，这时候A进入到TIME_WAIT状态，等待2MSL（报文最大生存时间），以保证如果B最后发送的FIN在网络空间中消失，不会对后续的连接进行影响。

可以注意到在FIN_WAIT_2的阶段下，如果B不进行返回，A可能就无法从这个状态中切换出来，TCP没有对这个状态进行处理。但是在Linux下，可以通过设置TCP_FIN_timout来设置这个过程的超时时间。

## 如何保持可靠性

### 保证顺序

首先，如何保证包是顺序到达的。上一个包收到了，应答了，在发送一下个。这种模式被叫做**累计确认**。

在建立连接一开始的时候，每个包都会有一个ID，然后按照改ID一个个的发送，确保不丢失。

为了记录这些ID，所以TCP必须在两端都分别建立缓存来记录。分为了四种：

1. 发送了且确认了
2. 发送了还未确认
3. 没有发送已经在等待发送
4. 没有发送但是暂时还不会发送



这样我们发送端维护了一个队列，接收端会给发送端发送一个窗口的大小叫做 Advertise Window。这个窗口包含了2和3，超过了这个窗口的，接收端不能进行处理。

![建议窗口](https://dist.lyneee.com/blog/2021-09-08-advertise-window.webp)

同时在接收端也维护了一个数据结构，

1. 接受了，确认了
2. 接受了，未确认
3. 还没接受，

![接收端](https://dist.lyneee.com/blog/2021-09-08-client.webp)

- MaxRcvBuffer：最大缓存的量

接收端计算接受了还未确认的包的数量，而Advertise Window的大小则是，最大缓存量-等待未确认的数量。

2中的，包可能不是顺序的，如果出现了空档则， 可以立马进行回复，中间的空着的部分需要等待，哪怕是后续的包已经到达了。

### 超时重传

两张图中可以看到，发送端已经确认`1,2,3`已经到了，而接收端已经确认了`4,5`已经ack了。如果这个过程中5的ack丢掉了。

第一种方法就是进行 **超时重试** ，对每一个包发送了但是没有ack的设置一个定时器，超过了一定的时间则会重新进行尝试。如何确认这个超时的时间呢？

TCP会采样RTT的时间，然后加权平均，进行计算，这个值的大小，这个值是随着网络波动而变化的。对应的算法叫做 **自适应超时重传算法** 。

如果接着后续的包也常生了超时，TCP会 **超时时间加倍** 。第二次超时重传的时间设置为第一次的二倍。两次超时则说明网络环境差。

问题： **超时重传触发的时间，可能相对较长** ，如果接收端已经知道报文丢了，则直接会发送冗余ack要求重传。如下：

当接收端，收到了大于期望序号的报文段的时候，（也就是提前收到了一个包的ack，中间的某个包ack丢了），就会检测到数据流中的间隔，会发送冗余的ack，ack依然是期望接收到的报文段。在接收到三个冗余的ACK后，就会在定时器过期之前，重新传送丢失的报文段。不等超时了，直接重发。

### 流量控制

包的ack中，会携带一个窗口大小。如果发送的慢了则会增加窗口的大小。如果发送的快了，接收端处理不过来，则窗口会越来越小，直到为0，停止发送。

### 拥塞控制

也是基于窗口大小来进行控制的，前面的滑动窗口rwnd，是为了防止，接收方的缓存被塞满。而这里的拥塞控制cwnd则是防止将网络塞满。

用一个公式来说 $LastByteSend - LastByteACKed <= min(cwnd, rwnd)$ ，也就是说，拥塞窗口和滑动窗口同时决定了控制的发送速度。

如何确定网络是阻塞还是通畅呢，对于TCP来说无法直接做到。所以TCP的拥塞控制就是在不阻塞的情况下，尽可能的发挥带宽，抢占贷款。

计算端到端网络容量，可以通过带宽*往返的延迟。拥塞控制主要防止丢包和超时重传。如果出现了这种情况说明了，发送速度太快了，导致传输过程中某个设备的缓存被吃满了，导致丢包。

所以TCP通过 **慢启动** 来进行控制。开始传送一个包，收到后在发送两个包，成指数型增长。当到了某个值的时候，一般是65535个字节，超过这个值的时候，则会成线性增长。

这时候，如果发生了丢包，则会把该阈值设置为 cwnd/2。上面提到的超时重传算法就会发挥作用。

但是仍然是有问题的，

- 丢包并不是意味着通道满了，网络总是会丢包的，这时候一味的折半，不能完全发挥网络性能
- 丢包可能真的是将中间设备填满，中间设备的缓存都满了导致丢包。

解决这个问题的算法，后面出现了 **TCP BBR 算法** ，也是我们经常可能在nas或者，机场里面看到的 BBR加速。

![bbr](https://dist.lyneee.com/blog/2021-09-08-bbr.webp)

