# Paxos、Zab和Raft

这三者都是强一致性，而Gossip等协议是弱一致性。

Paxos 是首个得到证明并被广泛应用的共识算法，其原理类似 [两阶段提交](https://en.wikipedia.org/wiki/Two-phase_commit_protocol) 算法，进行了泛化和扩展，通过消息传递来逐步消除系统中的不确定状态。作为后来很多共识算法（如 Raft、ZAB 等）的基础，变得更加简练和可实现，从而应用到生产环境中。

## Paxos

Paxos 问题是指分布式的系统中存在故障（crash fault），但不存在恶意（corrupt）消息节点的场景（即可能消息丢失或重复，但无错误消息）下的共识达成问题。这也是分布式共识领域最为常见的问题。

1990 年由 Leslie Lamport 在论文《The Part-time Parliament》中提出的 [Paxos](http://research.microsoft.com/users/lamport/pubs/lamport-paxos.pdf) 共识算法，在工程角度实现了一种最大化保障分布式系统一致性（存在极小的概率无法实现一致）的机制。

论文中为了描述问题编造了一个虚构故事：在古代爱琴海的 Paxos 岛，议会如何通过表决来达成共识。议员们通过信使传递消息来对议案进行表决。但议员可能离开，信使可能走丢，甚至重复传递消息。

### 原理

算法中存在三种基本的逻辑角色，实现中一个节点可以担任多个角色。

- 提案者Proposer：提出一个提案等待大家批准，然后结案。系统中每一个提案都用一个字赠序号进行标识。这一角色一般由客户端来担任。
- 接受者Accepter：负责对提案进行投票，接受提案。一般由服务端来担任。
- 学习者Learner：获得批准，接受存储达成共识的值，帮忙传播，不参与投票过程。可以为客户端也可以是服务端。

算法需要对 **安全性** 和 **存活性** 进行保证。

- 安全性： 决议的结果是对的，无歧义的，不会出现错误情况。
  - 在一次执行过程中，只会处理一个提案，只批准一个最终决议，被多数接受者接受的结果成为决议
- 存活性：保证决议在有限的时间内完成
  - 决议总是会产生，学习者会获得最后批准的决议

基本思路类似两阶段提交：多个提案者先要争取到提案的权利（得到大多数接受者的支持）；成功的提案者发送提案给所有人进行确认，得到大部分人确认的提案成为批准的结案。

如果提案者故障，从集群中选出新的提案者即可；如果接受者故障，表决时能够达成多数派也没有问题。

**潜在的问题** 是可能形成 **活锁** ，如果多个提案者不断的向接收者发送提案，还没有等待上一个提案达到多数下一个提案又来了，导致接受这转向处理新的提案，所有的都没有办法通过。

### 探讨

#### 一个提案者+多个接受者

如果系统中限定只允许某个特定节点是提案者，那么共识结果很容易能达成（只有一个方案，要么达成，要么失败）。提案者只要收到了来自多数接受者的投票，即可认为通过，因为系统中不存在其他的提案。

但此时 **一旦提案者故障** ，则整个系统无法工作。

#### 多个提案者+一个接受者

限定某个特定节点作为接受者。这种情况下，共识也很容易达成，接受者收到多个提案，选第一个提案作为决议，发送给其它提案者即可。缺陷也是容易发生单点故障，包括接受者故障或首个提案者节点故障。以上两种情形其实类似主从模式，虽然不那么可靠，但因为原理简单而被广泛采用。

#### 多个提案者+多个接受者

一种情况是 **同一时间片段（如一个提案周期）内只有一个提案者** ，这时可以退化到单提案者的情形。需要设计一种机制来保障提案者的正确产生，例如按照时间、序列之类。考虑到分布式系统要处理的工作量很大，这个过程要尽量高效，满足这一条件的机制非常难设计。

另一种情况是 **允许同一时间片段内可以出现多个提案者**  。那同一个节点可能收到多份提案，怎么对他们进行区分呢？这个时候采用只接受第一个提案而拒绝后续提案的方法也不适用。很自然的，提案需要带上不同的序号。节点需要根据提案序号来判断接受哪个。比如接受其中序号较大（往往意味着是接受新提出的，因为旧提案者故障概率更大）的提案。

同时允许多个提案，意味着很可能单个提案人无法集齐足够多的投票；另一方面，提案者即便收到了多数接受者的投票，也不敢说就一定通过。因为在此过程中投票者无法获知其它投票人的结果，也无法确认提案人是否收到了自己的投票。因此，需要实现两个阶段的提交过程。

#### 两阶段的提交

提案者发出提案申请之后，会收到来自接受者的反馈。一种结果是提案被大多数接受者接受了，一种结果是没被接受。没被接受的话，可以过会再重试。即便收到来自大多数接受者的答复，也不能认为就最终确认了。因为这些接受者自己并不知道自己刚答复的提案可以构成大多数的一致意见。

很自然的，需要引入新的一个阶段，即提案者在第一阶段拿到所有的反馈后，需要再次判断这个提案是否得到大多数的支持，如果支持则需要对其进行最终确认。

Paxos 里面对这两个阶段分别命名为 **准备（Prepare）** 和 **提交（Commit）** 。准备阶段通过锁来解决对哪个提案内容进行确认的问题，提交阶段解决大多数确认最终值的问题。

**准备阶段**：

- 提案者发送自己计划提交的提案的编号到多个接受者，试探是否可以锁定多数接受者的支持。
- 接受者时刻保留收到过提案的最大编号和接受的最大提案。如果收到提案号比目前保留的最大提案号还大，则返回自己已接受的提案值（如果还未接受过任何提案，则为空）给提案者，更新当前最大提案号，并说明不再接受小于最大提案号的提案。

**提交阶段**：

- 提案者如果收到大多数的回复（表示大部分人听到它的请求），则可准备发出带有刚才提案号的接受消息。如果收到的回复中不带有新的提案，说明锁定成功。则使用自己的提案内容；如果返回中有提案内容，则替换提案值为返回中编号最大的提案值。如果没收到足够多的回复，则需要再次发出请求。
- 接受者收到接受消息后，如果发现提案号不小于已接受的最大提案号，则接受该提案，并更新接受的最大提案。

一旦多数接受者接受了共同的提案值，则形成决议，成为最终确认。

!!! note 
		但是Paxos协议并不容易实现，zab和raft对Paxos算法进行了简化和改进。

### Multi Paxos

对接受者设置主从节点。



## Raft

三个子问题： 1. 领导者选举； 2.日志复制；3.安全以及恢复。

重新定义了状态，领导者、跟随者以及参选者。

raft中有两种超时时间。

### 领导者选举

首先，所有节点都会被设置随机设置一个选举超时时间从150ms-300ms。在超时时间结束后，follower会变成参选者状态。会给自己先投一票，然后给其他节点发送投票请求。其他节点的将会重置选举超时时间 reset election timeout。参选者收到大于一半的选票后，会成为主节点。并开始向从节点间隔发送心跳包，间隔时间被称为 heartbeat timeout。从节点也会回复一个心跳包给leader节点

如果，是偶数节点，且两个节点的平票的情况下，会再次进行投票。

### 日志复制

如果写入了一个值到主节点上，修改值会跟随着下一个心跳包到达follower节点上，如果绝大多数从节点回复收到了这个修改值操作，则会返回一个相应给客户端，同时将值修改提交到从节点上。（两阶段提交）



### 脑裂？

当网络发生分区后，不同的分区会产生新的leader，这时候会出现多个leader的情况。

![partitoin](https://dist.lyneee.com/blog/2021-09-25-partition-raft.png)

这时候进行只写入，客户端可能连接到了不同的leader上去，如果发送到少数的AB节点的分区上去，由于返回的票数少于节点值的一般，所以不会进行第二阶段的提交，设置失败。

如果连接到上方的集群，因为设置值的得票数大于了节点数的一半，则设置成功了。

### 安全以及恢复

分区隔离恢复时选择更高的election term的节点，term低的节点将进行回滚，然后匹配新leader的日志。

选择日志数量更高的节点。



## Zab

Zab（zookeeper atomic broadcast）是实现zookeeper的分布式一致性算法。

### 选择主节点

zab选择主节点分为了两个阶段

- discovery阶段通过多数follower的cepoch来确保有最新的commit和history
- synchronization阶段确保leader将最新的commit和history同步到了多数节点

### 广播逻辑broadcast 

会参照discovery阶段选择所有节点中最新的history。

写入失败不一定失败，但是写入成功可以确保成功。



## zab和raft

相同：

- 主从模式
- 任期概念 raft（term）以及zab（epoch）

不同点：

- 选择主节点的逻辑不一样
  - raft：超时触发选择主节点
  - zab：使用两阶段选择主节点
- 实现上raft考虑了更多的细节，日志压缩等等。



## 参考网站：

1. https://raft.github.io/
2. http://thesecretlivesofdata.com/raft/#replication

