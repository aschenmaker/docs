# CAP 理论

## 1定义

!!! note "CAP理论"

		在理论计算机科学中，**CAP定理**（CAP theorem），又被称作 **布鲁尔定理**（Brewer's theorem），它指出对于一个分布式计算系统来说，不可能同时满足以下三点：
		
		- 一致性（Consistency） 等同于所有节点访问同一份最新的数据副本
		- 可用性（Availability）每次请求都能获取到非错的响应——但是不保证获取的数据为最新数据
		- 分区容错性（Partition tolerance）以实际效果而言，分区相当于对通信的时限要求。系统如果不能在时限内达成数据一致性，就意味着发生了分区的情况，必须就当前操作在C和A之间做出选择。



![cap](https://dist.lyneee.com/blog/2021-09-24-cap-th.png)

从CAP理论中我们知道，同时保证三者是不可能的。

## 2解释

### 2.1 分区容忍性

为了消除迷思，我们必须弄清楚，什么是 **分区容忍性** ，

**P是什么：** 分区容忍性说起来是一个很模糊的概念，下面引入两个说法进行理解。

- Stonebraker博士断言，如果网络故障时，分区两边的处理可以继续，那就是分区容忍的。
- Gilbert和Lynch是这样定义分区容忍性的：网络允许丢失以一个节点发给另一个节点的任意多的消息。

我们无法构建完全可靠的网络和系统来消除，构建完全没有丢包、延迟、或者绝不出现问题的网络是不切实际的。不同分区之间进行交流的故障，分布式系统中，P一定会发生，否则也不会是分布式了。

所以，大部分时候我们需要在A和C中权衡， **因为，分布式系统中的P，分区一定会发生** ，这其实是A和C的战争 [^1]。

1. 如果选择了C，则需要保证数据的一致性，这样则会放弃掉一定的可用性，其他分区可能不会立即确认当前分区数据是否一致。
2. 如果选择了A，为了保证高可用，数据可能直接会从当前分区返回，但是和其他分区中的数据不一致

### 2.2一致性

在实现一致性中，会有两种比较常见的原则和理论，`ACID`以及`BASE`。

#### 2.2.1 ACID

为了保证数据的一致性，有非常经典的 `ACID` 来描述一致性需求，也就是常出现在数据库的保证事务的一致性中。，即 `原子性Atomicity`，`一致性Consistency`，`隔离性Isolation`，`持久性 Durability`。

`ACID` 满足了一致性需求，但是牺牲了部分的可用性作为代价。

-  **Atomicity**：每次事务的提交是原子的，要么全部成功，要么全部失败。一旦产生了失败则会退到事务执行之前的状态。
-  **Consistency**：数据库状态在事务执行完成前和完成后是一直和完整的，没有中间状态存在。只能处于事务执行成功之后的状态。
-  **Isolation**：各种事务是独立执行的，彼此之间不会互相干扰。在SQL标准中，会有四种隔离级别，由弱到强：未授权读（未提交读Read Uncommitted）、授权读（提交读Read Committed）、可重复读（ Repeated Read）和串行化（Serializable）。
-  **Durability**：状态修改后，改变是持久的，不会失效。一旦某个事物提交，它带来的改变就是永久的。

#### 2.2.2 BASE

>  CAP理论的提出者Brewer指出：在分布式系统中，计算是相对容易的，真正困难的是状态的维护。那么对于分布式存储或者说数据共享系统，数据的一致性保证也是比较困难的。对于传统的关系型数据库，优先考虑的是一致性而不是可用性，因此提出了事务的ACID特性。而对于许多分布式存储系统，则是更看重可用性而不是一致性，**一致性通过BASE**（Basically Available, Soft state, Eventual consistency）来保证

BASE的目标是实现 **最终一致性** ，来换取系统的可用性。



!!! tip
		**BASE理论** 和 **ACID原则** 看起来是对立的，其实在CAP理论中，牺牲了不同的部分，前者保证了高可用，后者则是牺牲了高可用来保证一致性。



#### 2.2.3 "2PC"和 "3PC"

对于分布式事务一致性的研究成果包括著名的 **两阶段提交算法（Two-phase Commit，2PC）**和 **三阶段提交算法（Three-phase Commit，3PC）**。

**2PC**

两阶段提交算法基本思想十分简单，既然在分布式场景下，直接提交事务可能出现各种故障和冲突，那么可将其分解为预提交和正式提交两个阶段，规避冲突的风险。

1. 预提交：协调者（Coordinator）发起提交某个事务的申请，各参与执行者（Participant）需要尝试进行提交并反馈是否能完成；
2. 正式提交：协调者如果得到所有执行者的成功答复，则发出正式提交请求。如果成功完成，则算法执行成功。

如果在这个过程中任何步骤出现了问题，则回退。即所有的节点同意了事务（事务可以在所有节点达成）则提交该事物，负责放弃。

两阶段提交算法因为其简单容易实现的优点，在关系型数据库等系统中被广泛应用。当然，其缺点也很明显。

1. 整个过程需要同步阻塞导致性能一般较差；
2. 同时存在单点问题，较坏情况下可能一直无法完成提交；
3. 另外可能产生数据不一致的情况（例如协调者和执行者在第二个阶段出现故障）。

**3PC**

三阶段提交针对两阶段提交算法第一阶段中可能阻塞部分执行者的情况进行了优化。具体来说，将预提交阶段进一步拆成两个步骤：尝试预提交和预提交。

- 尝试预提交：协调者询问执行者是否能进行某个事务的提交。执行者需要返回答复，但无需执行提交。这就避免出现部分执行者被无效阻塞住的情况。
- 预提交：协调者检查收集到的答复，如果全部为真，则发起提交事务请求。各参与执行者（Participant）需要尝试进行提交并反馈是否能完成；
- 正式提交：协调者如果得到所有执行者的成功答复，则发出正式提交请求。如果成功完成，则算法执行成功。

无论两阶段还是三阶段提交，都只是一定程度上缓解了提交冲突的问题，并无法一定保证系统的一致性。首个有效的算法是后来提出的 Paxos 算法。

### 2.3可用性

衡量可靠性一般有SLA，即“几个 9”的指标来衡量。

提高可靠性主要由两个方式

- 一是，让系统中的组件都变得可靠
  - 使用生产级别的设备，如自纠错内存、生产级路由等等。
- 二是，干脆消灭单点
  - 让单点的服务，以主从形式、或者多活等模式进行服务。

## 3应用场景

具体的场景，算法，技术组件如下表示

| CAP  | 场景、算法、组件                                             | 解释                                                     |
| ---- | ------------------------------------------------------------ | -------------------------------------------------------- |
| CA   | 非分布式场景，一般单机环境下能够同时对一致性和高可用进行保证 | 分布式系统中的P，分区一定会发生，没有P则不是分布式系统。 |
| CP   | Paxos、Raft等算法，例如金融计算等场景，技术组件有Redis、ETCD等等 | 保证数据一致性，削弱可用性                               |
| AP   | Gossip等协议，实时性较弱的查询类数据库、网站静态页面内容等等，技术组件如Cassandra等 | 保证可用性，弱化一致性                                   |

另外，削弱分区容忍性带来的问题可以通过一下几种方式

1. 两阶段提交，
2. 网络通过双通道来增强可靠性。



[^1]: 更好的cap解释 https://dzone.com/articles/better-explaining-cap-theorem
