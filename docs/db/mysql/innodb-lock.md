# Innodb中事务隔离级别和锁的关系

!!! note 
    本文记录于美团技术博客
    - 介绍了事务隔离级别
    - 以及如何使用锁达成对应的控制
    - 介绍了MVCC

## 1.Intro

事务的四种性质ACID，原子性、一致性、隔离性、持久性。确保了事务是正确可靠的。

- **原子性**（Atomicity）：一个事务（transaction）中的所有操作，或者全部完成，或者全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。即，事务不可分割、不可约简。
- **一致性**（Consistency）：在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设[约束](https://zh.wikipedia.org/wiki/数据完整性)、[触发器](https://zh.wikipedia.org/wiki/触发器_(数据库))、[级联回滚](https://zh.wikipedia.org/wiki/级联回滚)等。
- **隔离性**（Isolation）：数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别：
    - 包括未提交读（Read uncommitted）、
    - 提交读（read committed）、
    - 可重复读（repeatable read）
    - 串行化（Serializable）。
- **持久性**（Durability）：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失.[^1]

[^1]: https://zh.wikipedia.org/wiki/ACID#cite_note-acid-1

在隔离性和一致性上，一般采用加锁的方式。因为数据库是个高并发应用，同一时间会有大量的并发访问。如果过度加锁，会极大的影响并发处理能力。所以对于加锁的处理，可以说就是数据库对于事务处理的精髓所在。

## 2.一次加锁还是两段锁

一般应用都是一次加锁，提前知道哪些数据会被用到，然后全部锁住，运行完成后，释放锁，能够有效的避免循环死锁。但是数据库中不适用，数据库不会知道哪些数据会被用到。

所以数据库使用了两段锁。将事物分为了两个阶段，加锁阶段，和解锁阶段。

- 加锁阶段：在该阶段可以进行加锁操作。在对任何数据进行读操作之前要申请并获得S锁（共享锁，其它事务可以继续加共享锁，但不能加排它锁），在进行写操作之前要申请并获得X锁（排它锁，其它事务不能再获得任何锁）。加锁不成功，则事务进入等待状态，直到加锁成功才继续执行。
- 解锁阶段：当事务释放了一个封锁以后，事务进入解锁阶段，在该阶段只能进行解锁操作不能再进行加锁操作。

| 事务                      | 加锁/解锁                                      |
| ------------------------- | ---------------------------------------------- |
| begin;                    |                                                |
| Insert into xxx_table.... | 加insert锁                                     |
| update xxx_table set ...  | 加update对应的锁                               |
| delete from xxx_table ... | 加delete对应的锁                               |
| commit;                   | 事务提交时，同时释放insert, update, delete的锁 |

这种方式虽然无法避免死锁，但是两段锁协议可以保证事务的并发调度是串行化（串行化很重要，尤其是在数据恢复和备份的时候）的。

## 3.事务的加锁方式

### 3.1事务的四种隔离级别

事务中为了保证数据的正确性，提出了事务的隔离级别。

- 脏读：一个事务读取到了另外一个事务未提交的数据
- 不可重复读：一个事务在多次读取表中的一行数据时，数据不一致。
- 幻读：事务不是独立执行的，读取到了其他事物新增的数据。

| 隔离级别 | 脏读（Dirty Read） | 不可重复读（NonRepeatable Read） | 幻读（Phantom Read） |
| :------- | :----------------- | :------------------------------- | :------------------- |
| 未提交读 | 可能               | 可能                             | 可能                 |
| 已提交读 | 不可               | 可能                             | 可能                 |
| 可重复读 | 不可能             | 不可能                           | 可能                 |
| 可穿行化 | 不可能             | 不可能                           | 不可能               |

- 未提交读：允许脏读，也就是能够读取到其他事物中没有提交的数据；
- 提交读：只能够读取已经提交的数据。Oracle等多数数据库的默认是该级别的；
- 可重复读：在同一个事物内的查询都是事物开始时刻一致的，**InnoDB的默认**级别。但是还是存在幻读的情况，可能事物前后对应的数据不一致。
- 串行读：完全串行化的读，每次读都需要表级别的共享锁，读写都会阻塞。

### 3.2Mysql中锁的种类

MySQL中锁的种类很多，有常见的表锁和行锁，也有新加入的Metadata Lock等等，

表锁是对一整张表加锁，虽然可分为读锁和写锁，但毕竟是锁住整张表，会导致并发能力下降，一般是做ddl处理时使用，例如给表加入索引等操作，

行锁则是锁住数据行，这种加锁方法比较复杂，但是由于只锁住有限的数据，对于其它数据不加限制，所以并发能力强，MySQL一般都是用行锁来处理并发事务。

### 3.3提交读（Read Committed）

已提交读，读取的数据时不加锁的，但是数据的写入、修改和删除时需要加锁的。

```sql
MySQL> show create table class_teacher \G\
Table: class_teacher
Create Table: CREATE TABLE `class_teacher` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `class_name` varchar(100) COLLATE utf8mb4_unicode_ci NOT NULL,
  `teacher_id` int(11) NOT NULL,
  PRIMARY KEY (`id`),
  KEY `idx_teacher_id` (`teacher_id`)
) ENGINE=InnoDB AUTO_INCREMENT=5 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci

MySQL> select * from class_teacher;
+----+--------------+------------+
| id | class_name   | teacher_id |
+----+--------------+------------+
|  1 | 初三一班     |          1 |
|  3 | 初二一班     |          2 |
|  4 | 初二二班     |          2 |
+----+--------------+------------+
```

Innodb的默认隔离级别时RR级别的，可重复读级别的。所以首先得讲会话开启成为RC级别的，并且设置binlog模式。

```sql
SET session transaction isolation level read committed;
SET SESSION binlog_format = 'ROW';（或者是MIXED）
```

| 事务A                                                        | 事务B                                                        |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| begin;                                                       | begin;                                                       |
| update class_teacher set class_name=‘初三二班’ where teacher_id=1; | update class_teacher set class_name=‘初三三班’ where teacher_id=1; |
| commit;                                                      |                                                              |

为了防止并发过程中的修改冲突，事务A中MySQL给teacher_id=1的数据行加锁，并一直不commit（释放锁），那么事务B也就一直拿不到该行锁，wait直到超时。

这时我们要注意到，teacher_id是有索引的，如果是**没有索引**的class_name呢？update class_teacher set teacher_id=3 where class_name = ‘初三一班’; 那么MySQL会给**整张表的所有数据行**的加行锁。

这里听起来有点不可思议，但是当sql运行的过程中，MySQL并不知道哪些数据行是 class_name = ‘初三一班’的（**没有索引**嘛），**如果一个条件无法通过索引快速过滤，存储引擎层面就会将所有记录加锁后返回**，再由MySQL Server层进行过滤。

但在实际使用过程当中，MySQL做了一些改进，在MySQL Server过滤条件，发现不满足后，会调用unlock_row方法，把不满足条件的记录释放锁 (违背了二段锁协议的约束)。这样做，保证了最后只会持有满足条件记录上的锁，但是每条记录的加锁操作还是不能省略的。可见即使是MySQL，为了效率也是会违反规范的。[^ 2]

[^2]:（参见《高性能MySQL》中文第三版p181）

这种情况同样适用于MySQL的默认隔离级别RR。所以对一个数据量很大的表做批量修改的时候，如果无法使用相应的索引，MySQL Server过滤数据的的时候特别慢，就会出现虽然没有修改某些行的数据，但是它们还是被锁住了的现象。

### 3.4可重复读（Repeatable Read）

这是InnoDB默认的隔离级别，

#### 3.4.1 读

读也就是，可重复读。可重复读这一概念：一事务的多个实例在并发读取数据的时，会看到同样的数据行。

RC（不可重读）模式下的展现：

| 事务A                                                        | 事务B                                                      |
| :----------------------------------------------------------- | :--------------------------------------------------------- |
| begin;                                                       | begin;                                                     |
| select id,class_name,teacher_id from class_teacher where teacher_id=1; |                                                            |
|                                                              | update class_teacher set class_name='初三三班' where id=1; |
|                                                              | commit;                                                    |
| select id,class_name,teacher_id from class_teacher where teacher_id=1; |                                                            |
| commit;                                                      |                                                            |

这时候事务A会读取到事务B刚更新后的结果。一次同样的查询，前后结果不一致，这就是导致了不可重复读。

RR级别下的

| 事务A                                                        | 事务B                                                        | 事务C                                                        |
| :----------------------------------------------------------- | :----------------------------------------------------------- | :----------------------------------------------------------- |
| begin;                                                       | begin;                                                       | begin;                                                       |
| select id,class_name,teacher_id from class_teacher where teacher_id=1;i |                                                              |                                                              |
|                                                              | update class_teacher set class_name='初三三班' where id=1;**commit;** |                                                              |
|                                                              |                                                              | insert into class_teacher values (null,'初三三班',1);**commit;** |
| select id,class_name,teacher_id from class_teacher where teacher_id=1; |                                                              |                                                              |
| commit;                                                      |                                                              |                                                              |

事务A先做了一次读取，事务B中间修改了id=1的数据，并commit之后，事务A第二次读到的数据和第一次完全相同。所以说它是可重读的。那么MySQL是怎么做到的呢？这里姑且卖个关子，我们往下看。

### 3.5 不可重复读和幻读的区别

不可重复读的重点在于update和delete，而幻读的重点在insert上。

如果使用锁机制来实现这两种隔离级别，在可重复读中，该sql第一次读取到数据后，就将这些数据加锁，其它事务无法修改这些数据，就可以实现可重复读了。

但这种方法却无法锁住insert的数据，所以当事务A先前读取了数据，或者修改了全部数据，事务B还是可以insert数据提交，这时事务A就会发现莫名其妙多了一条之前没有的数据，这就是幻读，不能通过行锁来避免。

需要Serializable隔离级别 ，读用读锁，写用写锁，读锁和写锁互斥，这么做可以有效的避免幻读、不可重复读、脏读等问题，但会极大的降低数据库的并发能力。

所以说不可重复读和幻读最大的区别，就在于如何通过锁机制来解决他们产生的问题。

MySQL、ORACLE、PostgreSQL等成熟的数据库，出于性能考虑，都是使用了以乐观锁为理论基础的MVCC（多版本并发控制）来避免这两种问题。

## 乐观锁和悲观锁

### 悲观锁

正如其名，它指的是对数据被外界（包括本系统当前的其他事务，以及来自外部系统的事务处理）修改持保守态度，因此，在整个数据处理过程中，将数据处于锁定状态。悲观锁的实现，往往依靠数据库提供的锁机制（也只有数据库层提供的锁机制才能真正保证数据访问的排他性，否则，即使在本系统中实现了加锁机制，也无法保证外部系统不会修改数据）。

在悲观锁的情况下，为了保证事务的隔离性，就需要一致性锁定读。读取数据时给加锁，其它事务无法修改这些数据。修改删除数据时也要加锁，其它事务无法读取这些数据。

### 乐观锁

相对悲观锁而言，乐观锁机制采取了更加宽松的加锁机制。悲观锁大多数情况下依靠数据库的锁机制实现，以保证操作最大程度的独占性。但随之而来的就是数据库性能的大量开销，特别是对长事务而言，这样的开销往往无法承受。

而乐观锁机制在一定程度上解决了这个问题。乐观锁，大多是基于数据版本（ Version ）记录机制实现。何谓数据版本？即为数据增加一个版本标识，在基于数据库表的版本解决方案中，一般是通过为数据库表增加一个 “version” 字段来实现。读取出数据时，将此版本号一同读出，之后更新时，对此版本号加一。此时，将提交数据的版本数据与数据库表对应记录的当前版本信息进行比对，如果提交的数据版本号大于数据库表当前版本号，则予以更新，否则认为是过期数据。

### MVCC在MySQL的InnoDB中的实现

在InnoDB中，会在每行数据后添加两个额外的隐藏的值来实现MVCC，这两个值一个记录这行数据何时被创建，另外一个记录这行数据何时过期（或者被删除）。 在实际操作中，存储的并不是时间，而是事务的**版本号**，每开启一个新事务，事务的版本号就会递增。 

在可重读Repeatable reads事务隔离级别下：

- SELECT时，读取创建版本号<=当前事务版本号，删除版本号为空或>当前事务版本号。
- INSERT时，保存当前事务版本号为行的创建版本号
- DELETE时，保存当前事务版本号为行的删除版本号
- UPDATE时，插入一条新纪录，保存当前事务版本号为行创建版本号，同时保存当前事务版本号到原来删除的行

通过MVCC，虽然每行记录都需要额外的存储空间，更多的行检查工作以及一些额外的维护工作，但可以减少锁的使用，大多数读操作都不用加锁，读数据操作很简单，性能很好，并且也能保证只会读取到符合标准的行，也只锁住必要行。



## 原文地址
https://tech.meituan.com/2014/08/20/innodb-lock.html